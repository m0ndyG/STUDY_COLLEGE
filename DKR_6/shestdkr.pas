program shestdkr;

uses
  crt, dynqueue, staticqueue; // Подключаем модули для работы с консолью, динамическими и статическими очередями

function mainMenu: integer; // Функция для вывода меню
var
  sel: integer; // Переменная для хранения выбранного пункта меню
begin
  repeat
    clrscr; // Очищаем консоль
    writeln('1 - ДОБАВИТЬ ЭЛЕМЕНТ В ОЧЕРЕДЬ'); // Вывод пунктов меню
    writeln('2 - УДАЛИТЬ ЭЛЕМЕНТ ИЗ ОЧЕРЕДИ');
    writeln('3 - ПЕЧАТЬ ЭЛЕМЕНТОВ ОЧЕРЕДИ ОТ НАЧАЛА К КОНЦУ');
    writeln('4 - ПЕЧАТЬ ПЕРВОГО ЭЛЕМЕНТА В ОЧЕРЕДИ');
    writeln('5 - ПОЛУЧИТЬ КОЛИЧЕСТВО ЭЛЕМЕНТОВ ОЧЕРЕДИ');
    writeln('6 - ВЫЙТИ В ГЛАВНОЕ МЕНЮ');
    writeln('7 - ВЫХОД');
    write('Выберите один из пунктов меню: ');
    readln(sel); // Считываем выбор пользователя
  until ((sel >= 1) and (sel <= 7)); // Проверяем корректность ввода
  writeln;
  mainMenu := sel; // Возвращаем выбранный пункт
end;

procedure choiceMemory(var isDynamic: boolean); // Процедура для выбора типа реализации очереди
var
  choice: integer; // Переменная для хранения выбранного типа
begin
  repeat
    clrscr; // Очищаем консоль
    writeln('Выберите способ реализации очереди:'); // Вывод вариантов реализации
    writeln('1 - Динамическая реализация');
    writeln('2 - Статическая реализация');
    write('Ввод: ');
    readln(choice); // Считываем выбор пользователя
    case choice of // Обработка выбора
      1: isDynamic := true; // Устанавливаем флаг динамической реализации
      2: isDynamic := false; // Устанавливаем флаг статической реализации
    else
      writeln('Неверный выбор!'); // Ошибка при неверном выборе
    end;
  until (choice in [1, 2]); // Проверяем корректность ввода

  if isDynamic then
    dynqueue.begQ := NIL // Инициализируем динамическую очередь
  else
    staticqueue.initStaticQueue; // Инициализируем статическую очередь
end;

var
  sel: integer; // Переменная для хранения выбранного пункта меню
  elem: char; // Переменная для хранения элемента очереди
  isDynamic: boolean; // Флаг для определения типа реализации очереди

begin
  choiceMemory(isDynamic); // Вызываем процедуру выбора типа реализации

  repeat
    sel := mainMenu; // Выводим главное меню и получаем выбранный пункт
    case sel of
      1: // Добавление элемента в очередь
      begin
        if isDynamic then // Если используется динамическая реализация
        begin
          dynqueue.addDynamicElem; // Вызываем процедуру добавления элемента в динамическую очередь
          writeln('Элемент успешно добавлен в конец очереди!');
        end
        else // Если используется статическая реализация
        begin
          write('Введите значение добавляемого элемента: ');
          readln(elem); // Считываем значение элемента
          staticqueue.addStaticElem(elem); // Вызываем процедуру добавления элемента в статическую очередь
          writeln('Элемент успешно добавлен в конец очереди!');
        end;
        readkey; // Пауза для просмотра результата
      end;
      2: // Удаление элемента из очереди
      begin
        if isDynamic then // Если используется динамическая реализация
        begin
          if (dynqueue.begQ = NIL) then // Проверка на пустоту очереди
            writeln('В очереди нет ни одного элемента! Удаление невозможно!')
          else
          begin
            dynqueue.delDynamicElem; // Вызываем процедуру удаления элемента из динамической очереди
            writeln('Элемент успешно удален из начала очереди!');
          end;
        end
        else // Если используется статическая реализация
        begin
          elem := staticqueue.delStaticElem; // Вызываем процедуру удаления элемента из статической очереди
          if elem <> ' ' then // Если элемент был удален успешно
            writeln('Элемент ', elem, ' успешно удален из начала очереди!')
          else
            readkey; // Пауза для просмотра результата
        end;
      end;
      3: // Печать элементов очереди
      begin
        if isDynamic then // Если используется динамическая реализация
        begin
          if (dynqueue.begQ = NIL) then // Проверка на пустоту очереди
            writeln('В очереди нет ни одного элемента! Печать невозможна!')
          else
          begin
            write('Элементы очереди имеют вид: ');
            dynqueue.printDynamicQ; // Вызываем процедуру печати динамической очереди
          end;
        end
        else // Если используется статическая реализация
        begin
          staticqueue.printStaticQueue; // Вызываем процедуру печати статической очереди
        end;
        readkey; // Пауза для просмотра результата
      end;
      4: // Печать первого элемента очереди
      begin
        if isDynamic then // Если используется динамическая реализация
        begin
          if (dynqueue.begQ = NIL) then // Проверка на пустоту очереди
            writeln('В очереди нет ни одного элемента! Печать невозможна!')
          else
          begin
            write('Элементы очереди имеют вид: ');
            dynqueue.recPrintDynamicQ(dynqueue.begQ); // Вызываем рекурсивную процедуру печати динамической очереди
          end;
        end
        else // Если используется статическая реализация
        begin
          if staticqueue.isStaticQueueEmpty then // Проверка на пустоту очереди
            writeln('В очереди нет ни одного элемента! Печать невозможна!')
          else
          begin
            write('Элементы очереди имеют вид: ');
            staticqueue.printStaticQueue; // Вызываем процедуру печати статической очереди
          end;
        end;
        readkey; // Пауза для просмотра результата
      end;
      5: // Получение количества элементов в очереди
      begin
        if isDynamic then
          writeln('Количество элементов в очереди: ', dynqueue.getCountDynamicElem) // Вызываем функцию подсчета количества элементов динамической очереди
        else
        begin
          var i, p: integer;
          i := 0;
          p := staticqueue.front; // Начальный индекс статической очереди
          while p <> staticqueue.rear do // Проходим по всем элементам статической очереди
          begin
            inc(i); // Увеличиваем счетчик элементов
            p := (p + 1) mod MAX_QUEUE_SIZE; // Переход к следующему элементу
          end;
          writeln('Количество элементов в очереди: ', i);
        end;
        readkey; // Пауза для просмотра результата
      end;
      6: // Выход в главное меню
      begin
        choiceMemory(isDynamic); // Вызываем процедуру выбора типа реализации
      end;
    end;
  until sel = 7; // Цикл повторяется, пока пользователь не выберет выход
end.
